// Author: Ronaldo Engelke Cunha
// Class: CAP 5725
// Assignment: Assignment 6
// Date: 10/22/2022

#include <iostream>
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/mat4x4.hpp>
#include <glm/common.hpp>
#include <vector>
#include <Math.h>  
#include <cmath>
#include <stb_image.h>
#include <glm/gtc/type_ptr.hpp>

#define Pi 3.1415926535897932384626433832795

typedef struct {
	std::vector<float> positions;
	std::vector<float> normals;
	std::vector<float> texCoords;
	std::vector<unsigned int> indices;
} SphereData;

//vertex shader - processes input vertex data, usually normalizes and transforms input data to coordinates that fall within OpenGL's visible region
std::string vertexShaderProg = R"(#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 normal;
uniform mat4 view, projection, model;
out vec3 fragPosition, fragNormal;
void main()
{
	fragPosition = vec3(model * vec4(position, 1.0));
	fragNormal = mat3(transpose(inverse(model))) * normal;
	gl_Position = projection * view * model * vec4(position, 1.0);
})";

//fragment shader - calculates the color output of our pixels. Processes a fragment generated by the rasterization stage, into a set of colors and a single depth value.
std::string fragmentShaderProg = R"(#version 330 core
uniform samplerCube cubeMapTex;
in vec3 fragPosition, fragNormal;
uniform vec3 cameraPosition;
out vec4 outColor;
void main()
{
	vec3 N = normalize(fragNormal);
	vec3 V = normalize(cameraPosition - fragPosition);
	vec3 I = -V;
	vec3 R = reflect(I, N);
	vec3 envColor = (texture(cubeMapTex, R)).rgb;
	outColor = vec4(envColor, 1);
})";

std::string skyboxVertexShader = R"(#version 330 core
layout (location = 0) in vec3 position;
out vec3 fragPosition;
uniform mat4 projection;
uniform mat4 view;
void main()
{
	fragPosition = position;
	vec4 pos = projection * view * vec4(position, 1.0);
	gl_Position = pos.xyww; 
})";

std::string skyboxFragmentShader = R"(#version 330 core
in vec3 fragPosition;
out vec4 outColor;
uniform samplerCube cubeMapTex;
uniform mat4 view, projection;
uniform vec3 cameraPosition;
void main()
{
	//vec4 farPlanePosition = inverse(view * projection) * vec4(fragPosition, 1, 1);
	//vec3 direction = farPlanePosition.xyz/farPlanePosition.w - cameraPosition;
	//outColor = texture(cubeMapTex, normalize(direction));
	outColor = texture(cubeMapTex, fragPosition);
})";


SphereData genSphereData(float sphereRadius, int rows, int cols) {
	float PI = float(Pi);
	SphereData sp;

	for (int i = 0; i <= rows; i++) {
		float t = float(i) / float(rows);
		float theta = PI - t * PI;
		float y = float(cos(theta));
		float sinAngle = float(sin(theta));
		for (int j = 0; j <= cols; j++) {
			float s = float(j) / float(cols);
			float phi = 2. * s * PI;
			float x = -float(cos(phi)) * sinAngle;
			float z = float(sin(phi)) * sinAngle;
			sp.positions.push_back(sphereRadius * x); sp.positions.push_back(sphereRadius * y); sp.positions.push_back(sphereRadius * z);
			sp.normals.push_back(x); sp.normals.push_back(y); sp.normals.push_back(z);
			sp.texCoords.push_back(s); sp.texCoords.push_back(t);
		}
	}
	// calculate triangle indices
	for (int row = 1; row <= rows; row++) {
		for (int col = 0; col < cols; col++) {
			int index1 = (row - 1) * (cols + 1) + col,
				index2 = row * (cols + 1) + col,
				index3 = row * (cols + 1) + (col + 1);
			sp.indices.push_back(index1);
			sp.indices.push_back(index2);
			sp.indices.push_back(index3);

			index2 = index3;
			index3 = (row - 1) * (cols + 1) + (col + 1);
			sp.indices.push_back(index1);
			sp.indices.push_back(index2);
			sp.indices.push_back(index3);
		}
	}
	return sp;
}

std::vector<GLfloat> vertices;
std::vector<GLfloat> normals;
std::vector<GLuint> indices;
std::vector<GLuint> normalIndices;

glm::vec3 cameraUp, cameraPos, cameraFront;
glm::vec3 cameraPosSkybox;
float yaw = -90.0f;
float pitch, Radius;
float camX, camY, camZ;

float skyboxVertices2[] = {
	// positions          
	-1.0f,  1.0f, -1.0f,
	-1.0f, -1.0f, -1.0f,
	 1.0f, -1.0f, -1.0f,
	 1.0f, -1.0f, -1.0f,
	 1.0f,  1.0f, -1.0f,
	-1.0f,  1.0f, -1.0f,

	-1.0f, -1.0f,  1.0f,
	-1.0f, -1.0f, -1.0f,
	-1.0f,  1.0f, -1.0f,
	-1.0f,  1.0f, -1.0f,
	-1.0f,  1.0f,  1.0f,
	-1.0f, -1.0f,  1.0f,

	 1.0f, -1.0f, -1.0f,
	 1.0f, -1.0f,  1.0f,
	 1.0f,  1.0f,  1.0f,
	 1.0f,  1.0f,  1.0f,
	 1.0f,  1.0f, -1.0f,
	 1.0f, -1.0f, -1.0f,

	-1.0f, -1.0f,  1.0f,
	-1.0f,  1.0f,  1.0f,
	 1.0f,  1.0f,  1.0f,
	 1.0f,  1.0f,  1.0f,
	 1.0f, -1.0f,  1.0f,
	-1.0f, -1.0f,  1.0f,

	-1.0f,  1.0f, -1.0f,
	 1.0f,  1.0f, -1.0f,
	 1.0f,  1.0f,  1.0f,
	 1.0f,  1.0f,  1.0f,
	-1.0f,  1.0f,  1.0f,
	-1.0f,  1.0f, -1.0f,

	-1.0f, -1.0f, -1.0f,
	-1.0f, -1.0f,  1.0f,
	 1.0f, -1.0f, -1.0f,
	 1.0f, -1.0f, -1.0f,
	-1.0f, -1.0f,  1.0f,
	 1.0f, -1.0f,  1.0f
};


/// <summary>
/// Resize callback function for when window is resized by user. This adjusts the viewpoirt when the user resizes the window.
/// This function takes a window, and new window dimensions as parameters. Whenever the window changes in size, GLFW calls this function and fills in the proper arguments for you to process.
/// </summary>
/// <param name="window"></param>
/// <param name="width"></param>
/// <param name="height"></param>
void framebuffer_size_callback(GLFWwindow* window, int width, int height);

/// <summary>
/// Processes user input.
/// Processes user input.
/// </summary>
/// <param name="window"></param>
void processInput(GLFWwindow* window);

unsigned int compileShader(GLenum shaderType, const char* shaderProgram);
unsigned int compileCompleteShaders(const char* vertexShader, const char* fragmentShader);

int main()
{

	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", NULL, NULL);

	if (window == NULL)
	{
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window); //tell GLFW to make the context of our window the main context on the current thread

	if (glewInit() != GLEW_OK) //pass GLEW the function to load the address of the OpenGL function pointers which is OS-specific
	{
		std::cout << "Failed to initialize GLEW" << std::endl;
		return -1;
	}
	int width, height;
	width = 800;
	height = 600;
	glViewport(0, 0, width, height);

	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Radius = 1;
	int rows = 16, cols = 32;
	SphereData sp = genSphereData(Radius, rows, cols);
	std::cout << sp.positions.size() << " " << sp.normals.size() << " " << sp.indices.size() << std::endl;

	//Sphere VAO/VBO/EBO
	unsigned int VAO;
	glGenVertexArrays(1, &VAO);
	glBindVertexArray(VAO);

	unsigned int VBO;
	glGenBuffers(1, &VBO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sp.positions.size() * sizeof(GLfloat), sp.positions.data(), GL_STATIC_DRAW);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);
	
	unsigned int EBO;
	glGenBuffers(1, &EBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sp.indices.size() * sizeof(GLuint), sp.indices.data(), GL_STATIC_DRAW);

	//normals----------------------------------------------------------------------------------------------------
	unsigned int VBO_normals;
	glGenBuffers(1, &VBO_normals);
	glBindBuffer(GL_ARRAY_BUFFER, VBO_normals);
	glBufferData(GL_ARRAY_BUFFER, sp.normals.size() * sizeof(GLfloat), sp.normals.data(), GL_STATIC_DRAW);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(1);

	//Skybox----------------------------------------------------------------------------------------------------
	unsigned int VAO_Skybox, VBO_Skybox;
	glGenVertexArrays(1, &VAO_Skybox);
	glBindVertexArray(VAO_Skybox);

	glGenBuffers(1, &VBO_Skybox);
	glBindBuffer(GL_ARRAY_BUFFER, VBO_Skybox);
	glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices2), &skyboxVertices2[0], GL_STATIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);

	//load cube map texture---------------------------------------------------------------------------------------------------
	unsigned int textureID; 
	glGenTextures(1, &textureID);
	glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

	int imgWidth, imgHeight, nrChannels;
	unsigned char* data;

	const char* files[] = { "right.jpg" ,"left.jpg", "top.jpg", "bottom.jpg","front.jpg", "back.jpg", };
	for (int i = 0; i < 6; i++) {
		data = stbi_load(files[i], &imgWidth, &imgHeight, &nrChannels, 0);
		if (data)
		{
			glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, imgWidth, imgHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
			std::cout << "Cubemap texture " << files[i] << " loaded." << std::endl;
			stbi_image_free(data);
		}
		else
		{
			std::cout << "Cubemap texture " << files[i] << " failed to load." << std::endl;
		}
	}

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

	
	//camera----------------------------------------------------------------------------------------------------

	//perspective matrix
	float aspect = (float)width / (float)height;
	float near = 1, far = 100, fov = 45;
	//glm::mat4 proj = glm::perspective(glm::radians(fov), aspect, near, far);

	//positioning
	cameraPos = glm::vec3(0.0f, 0.0f, Radius * 5.0f);
	cameraPosSkybox = glm::vec3(0.0f, 0.0f, 1.0f);

	//direction
	glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f); //point to the origin of our scene
	glm::vec3 cameraDirectionVec = glm::normalize(cameraPos - cameraTarget); //get the vector to point in the positive z 

	//specify the up vector
	glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);

	//right vector will be the cross product of our up vector and the direction vector
	glm::vec3 cameraRightVec = glm::normalize(glm::cross(up, cameraDirectionVec));

	//get the camera up vector, we have the right and direction vector, cross product will result in the up vec
	cameraUp = glm::cross(cameraDirectionVec, cameraRightVec);
	cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);

	//------------------------------------------------------------------------------------------------------------

	////reseting all bindings
	glBindVertexArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	//compile complete shader program
	unsigned int completeShaderProg = compileCompleteShaders((const char*)vertexShaderProg.c_str(),(const char*) fragmentShaderProg.c_str()); //compile all the shaders
	glUseProgram(completeShaderProg);

	//set projection
	glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)width / (float)height, 0.1f, 100.0f);
	glUniformMatrix4fv(glGetUniformLocation(completeShaderProg, "projection"), 1, GL_FALSE, &projection[0][0]);

	//set camerapos 
	glUniform3fv(glGetUniformLocation(completeShaderProg, "cameraPosition"), 1, &cameraPos[0]);

	//now for creating the set of skybox shader progs------------------------------------------------------------//
	unsigned int completeSkyboxShaders = compileCompleteShaders((const char*)skyboxVertexShader.c_str(), (const char*)skyboxFragmentShader.c_str());
	glUseProgram(completeSkyboxShaders);

	glUniform3fv(glGetUniformLocation(completeSkyboxShaders, "cameraPosition"), 1, &cameraPos[0]);

	glEnable(GL_DEPTH_TEST);
	//render loop
	while (!glfwWindowShouldClose(window))
	{
		glm::mat4 view = glm::mat4(1.0f); 

		//input
		processInput(window);

		//render
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		//skybox rendering------------------------------------------------------------------------------------
		
		glDepthFunc(GL_LEQUAL);

		glUseProgram(completeSkyboxShaders);

		view = glm::lookAt(cameraPosSkybox, glm::vec3(0.0f, 0.0f, 0.0f), cameraUp);

		glUniformMatrix4fv(glGetUniformLocation(completeSkyboxShaders, "view"), 1, GL_FALSE, &view[0][0]);

		//set projection
		glUniformMatrix4fv(glGetUniformLocation(completeSkyboxShaders, "projection"), 1, GL_FALSE, &projection[0][0]);

		//set cameraPos
		glUniform3fv(glGetUniformLocation(completeSkyboxShaders, "cameraPosition"), 1, &cameraPosSkybox[0]);

		//bindings
		glBindVertexArray(VAO_Skybox);

		glActiveTexture(GL_TEXTURE0);

		glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

		glDrawArrays(GL_TRIANGLES, 0, 36);

		glBindVertexArray(0); //reset binding

		glDepthFunc(GL_LESS); // set depth function back to default

		//Sphere-------------------------------------
		
		//activate shader program
		glUseProgram(completeShaderProg);

		view = glm::lookAt(cameraPos, glm::vec3(0.0f, 0.0f, 0.0f), cameraUp);
		glUniformMatrix4fv(glGetUniformLocation(completeShaderProg, "view"), 1, GL_FALSE, &view[0][0]);

		//model
		glm::mat4 model = glm::mat4(1.0f);
		glUniformMatrix4fv(glGetUniformLocation(completeShaderProg, "model"), 1, GL_FALSE, &model[0][0]);

		//cameraPosition
		glUniform3fv(glGetUniformLocation(completeShaderProg, "cameraPosition"), 1, &cameraPos[0]);

		//bindings
		glBindVertexArray(VAO);

		glActiveTexture(GL_TEXTURE0);

		glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

		//render
		glDrawElements(GL_TRIANGLES, sp.indices.size(), GL_UNSIGNED_INT, NULL);

		glBindVertexArray(0); //reset binding

		// check and call events and swap the buffers
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	//now delete the individual shader objects once we've linked them into the program object, we don't need them anymore
	//glDeleteShader(vertexShader);
	//glDeleteShader(fragmentShader);

	glDeleteProgram(completeShaderProg);
	glDeleteVertexArrays(1, &VAO);
	glDeleteBuffers(1, &VBO);

	glfwTerminate();
	return 0;
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}

void processInput(GLFWwindow* window)
{
	const float cameraSpeed = 0.05f; // adjust accordingly

	//ESC
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);
	//W
	if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
	{
		pitch += (1.0f * cameraSpeed);
	}
	//S
	if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
	{
		pitch -= (1.0f * cameraSpeed);
	}
	//A
	if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
	{
		yaw += (1.0f * cameraSpeed);
	}
	//D
	if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
	{
		yaw -= (1.0f * cameraSpeed);
	}

	if (pitch > 89.0f)
		pitch = 89.0f;
	if (pitch < -89.0f)
		pitch = -89.0f;

	camX = (cos(glm::radians(yaw)) * cos(glm::radians(pitch))) ;
	camY = sin(glm::radians(pitch));
	camZ = sin(glm::radians(yaw)) * cos(glm::radians(pitch)) ;
	
	cameraPosSkybox = glm::vec3(camX, camY, camZ);
	cameraPos = glm::vec3(camX*6.0f, camY*6.0f, camZ*6.0f);
}

unsigned int compileShader(GLenum shaderType, const char* shaderProgram)
{
	//In order for OpenGL to use the shader it has to dynamically compile it at run - time from its source code.
	unsigned int shader = glCreateShader(shaderType); //define the type of shader we are creating

	//attach the vertex shader source code to the shader object and compile the shader
	glShaderSource(shader, 1, &shaderProgram, NULL);
	//The glShaderSource function takes the shader object to compile to as its first argument. The second argument specifies how many strings we're passing as source code, 
	//	which is only one. The third parameter is the actual source code of the vertex shader and we can leave the 4th parameter to NULL.
	glCompileShader(shader);

	//need to check if compilation of the vertex shader was successful
	int shaderCompiled;
	char log[512];
	//now check if the compilation was successful
	glGetShaderiv(shader, GL_COMPILE_STATUS, &shaderCompiled);

	//retrive the error message and log it, print it 
	if (!shaderCompiled)
	{
		glGetShaderInfoLog(shader, 512, NULL, log);
		std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << log << std::endl;
	}

	return shader;
}

unsigned int compileCompleteShaders(const char* vertexShader, const char* fragmentShader)
{
	unsigned int vertexCompiled = compileShader(GL_VERTEX_SHADER, vertexShader);
	unsigned int fragmentCompiled = compileShader(GL_FRAGMENT_SHADER, fragmentShader);
	char log[512];

	//now create the final linked version of all shader programs combined. Link all of the shader programs together into one single program, then activate this shader program when rendering objects.

	unsigned int completeShaderProgram = glCreateProgram(); //returns the ID reference to the newly created program object

	//now attach the previously compiled shaders to the program object and then link them
	glAttachShader(completeShaderProgram, vertexCompiled);
	glAttachShader(completeShaderProgram, fragmentCompiled);
	glLinkProgram(completeShaderProgram);

	//now check the success of the linking 
	int completeProgramSuccess;
	glGetProgramiv(completeShaderProgram, GL_LINK_STATUS, &completeProgramSuccess);

	if (!completeProgramSuccess)
	{
		glGetProgramInfoLog(completeShaderProgram, 512, NULL, log);
		std::cout << "ERROR::SHADER::PROGRAM::COMPILATION_FAILED\n" << log << std::endl;
	}

	return completeShaderProgram;
}
